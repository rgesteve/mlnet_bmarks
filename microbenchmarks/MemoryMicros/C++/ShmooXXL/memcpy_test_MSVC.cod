; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29334.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BI@MKMCHGM@?5?5?5?5?5?5memcpy?532?5bytes?3?5@ ; `string'
PUBLIC	??_C@_06IPDMOKPL@?$CF8lld?6@			; `string'
PUBLIC	??_C@_0BI@BABMNHLC@memcpy?5random?5lengths?3?5@	; `string'
PUBLIC	??_C@_0BI@MBDIOGAB@?5?5?5?5?5?5repmov?532?5bytes?3?5@ ; `string'
PUBLIC	??_C@_0BI@NLFGHJLN@repmov?5random?5lengths?3?5@	; `string'
EXTRN	memset:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	rand:PROC
EXTRN	__acrt_iob_func:PROC
EXTRN	srand:PROC
EXTRN	memcpy:PROC
EXTRN	__security_check_cookie:PROC
;	COMDAT ??_C@_0BI@NLFGHJLN@repmov?5random?5lengths?3?5@
CONST	SEGMENT
??_C@_0BI@NLFGHJLN@repmov?5random?5lengths?3?5@ DB 'repmov random lengths'
	DB	': ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MBDIOGAB@?5?5?5?5?5?5repmov?532?5bytes?3?5@
CONST	SEGMENT
??_C@_0BI@MBDIOGAB@?5?5?5?5?5?5repmov?532?5bytes?3?5@ DB '      repmov 32'
	DB	' bytes: ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BABMNHLC@memcpy?5random?5lengths?3?5@
CONST	SEGMENT
??_C@_0BI@BABMNHLC@memcpy?5random?5lengths?3?5@ DB 'memcpy random lengths'
	DB	': ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06IPDMOKPL@?$CF8lld?6@
CONST	SEGMENT
??_C@_06IPDMOKPL@?$CF8lld?6@ DB '%8lld', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MKMCHGM@?5?5?5?5?5?5memcpy?532?5bytes?3?5@
CONST	SEGMENT
??_C@_0BI@MKMCHGM@?5?5?5?5?5?5memcpy?532?5bytes?3?5@ DB '      memcpy 32 '
	DB	'bytes: ', 00H				; `string'
CONST	ENDS
PUBLIC	main
PUBLIC	printf
PUBLIC	_vfprintf_l
PUBLIC	__local_stdio_printf_options
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_cookie:QWORD
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN55
	DD	imagerel $LN55+463
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$repmovr DD imagerel repmovr
	DD	imagerel repmovr+23
	DD	imagerel $unwind$repmovr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$repmovr DD imagerel repmovr+23
	DD	imagerel repmovr+107
	DD	imagerel $chain$1$repmovr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$repmovr DD imagerel repmovr+107
	DD	imagerel repmovr+109
	DD	imagerel $chain$2$repmovr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$repmov32 DD imagerel repmov32
	DD	imagerel repmov32+22
	DD	imagerel $unwind$repmov32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$repmov32 DD imagerel repmov32+22
	DD	imagerel repmov32+103
	DD	imagerel $chain$1$repmov32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$repmov32 DD imagerel repmov32+103
	DD	imagerel repmov32+108
	DD	imagerel $chain$2$repmov32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memcpyr DD imagerel memcpyr
	DD	imagerel memcpyr+31
	DD	imagerel $unwind$memcpyr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$memcpyr DD imagerel memcpyr+31
	DD	imagerel memcpyr+136
	DD	imagerel $chain$3$memcpyr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$memcpyr DD imagerel memcpyr+136
	DD	imagerel memcpyr+147
	DD	imagerel $chain$4$memcpyr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memcpy32 DD imagerel memcpy32
	DD	imagerel memcpy32+29
	DD	imagerel $unwind$memcpy32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$memcpy32 DD imagerel memcpy32+29
	DD	imagerel memcpy32+113
	DD	imagerel $chain$2$memcpy32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$memcpy32 DD imagerel memcpy32+113
	DD	imagerel memcpy32+125
	DD	imagerel $chain$3$memcpy32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$repmov DD imagerel repmov
	DD	imagerel repmov+32
	DD	imagerel $unwind$repmov
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN6
	DD	imagerel $LN6+83
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041b01H
	DD	07017521bH
	DD	030156016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$repmov DD 040a01H
	DD	02740aH
	DD	016405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$memcpy32 DD 021H
	DD	imagerel memcpy32
	DD	imagerel memcpy32+29
	DD	imagerel $unwind$memcpy32
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$memcpy32 DD 061721H
	DD	087417H
	DD	07540dH
	DD	063405H
	DD	imagerel memcpy32
	DD	imagerel memcpy32+29
	DD	imagerel $unwind$memcpy32
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memcpy32 DD 040b01H
	DD	09640bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$memcpyr DD 021H
	DD	imagerel memcpyr
	DD	imagerel memcpyr+31
	DD	imagerel $unwind$memcpyr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$memcpyr DD 081c21H
	DD	0b741cH
	DD	0a6417H
	DD	09540dH
	DD	083405H
	DD	imagerel memcpyr
	DD	imagerel memcpyr+31
	DD	imagerel $unwind$memcpyr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memcpyr DD 040a01H
	DD	0f006320aH
	DD	0c002e004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$repmov32 DD 021H
	DD	imagerel repmov32
	DD	imagerel repmov32+22
	DD	imagerel $unwind$repmov32
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$repmov32 DD 040c21H
	DD	0740cH
	DD	026405H
	DD	imagerel repmov32
	DD	imagerel repmov32+22
	DD	imagerel $unwind$repmov32
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$repmov32 DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$repmovr DD 021H
	DD	imagerel repmovr
	DD	imagerel repmovr+23
	DD	imagerel $unwind$repmovr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$repmovr DD 040d21H
	DD	03740dH
	DD	026405H
	DD	imagerel repmovr
	DD	imagerel repmovr+23
	DD	imagerel $unwind$repmovr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$repmovr DD 010201H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	032119H
	DD	04806010fH
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	024020H
xdata	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$dead$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 642  :     {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	49 8b d9	 mov	 rbx, r9
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b f1	 mov	 rsi, rcx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	45 33 c9	 xor	 r9d, r9d
  00020	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00025	4c 8b c7	 mov	 r8, rdi
  00028	48 8b d6	 mov	 rdx, rsi
  0002b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002e	e8 00 00 00 00	 call	 __stdio_common_vfprintf

; 644  :     }

  00033	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00038	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0003d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 954  :     {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	53		 push	 rbx
  00015	56		 push	 rsi
  00016	57		 push	 rdi
  00017	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001b	48 8b f9	 mov	 rdi, rcx

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

  0001e	48 8d 74 24 58	 lea	 rsi, QWORD PTR _Format$[rsp+8]

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00023	b9 01 00 00 00	 mov	 ecx, 1
  00028	e8 00 00 00 00	 call	 __acrt_iob_func
  0002d	48 8b d8	 mov	 rbx, rax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00030	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00035	45 33 c9	 xor	 r9d, r9d
  00038	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0003d	4c 8b c7	 mov	 r8, rdi
  00040	48 8b d3	 mov	 rdx, rbx
  00043	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00046	e8 00 00 00 00	 call	 __stdio_common_vfprintf

; 959  :         __crt_va_end(_ArgList);
; 960  :         return _Result;
; 961  :     }

  0004b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004f	5f		 pop	 rdi
  00050	5e		 pop	 rsi
  00051	5b		 pop	 rbx
  00052	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Intel\ForVadim\memcpy_test_MSVC.c
;	COMDAT rdtsc
_TEXT	SEGMENT
rdtsc	PROC						; COMDAT

; 24   :     return __rdtsc();

  00000	0f 31		 rdtsc
  00002	48 c1 e2 20	 shl	 rdx, 32			; 00000020H
  00006	48 0b c2	 or	 rax, rdx

; 25   : }

  00009	c3		 ret	 0
rdtsc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Intel\ForVadim\memcpy_test_MSVC.c
;	COMDAT repmov
_TEXT	SEGMENT
dst$ = 8
src$ = 16
n$ = 24
repmov	PROC						; COMDAT

; 28   : {    

  00000	48 89 74 24 08	 mov	 QWORD PTR [rsp+8], rsi
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi

; 29   :     __movsb(dst, src, n);

  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	48 8b f2	 mov	 rsi, rdx
  00010	49 8b c8	 mov	 rcx, r8
  00013	f3 a4		 rep movsb

; 30   : }

  00015	48 8b 74 24 08	 mov	 rsi, QWORD PTR [rsp+8]
  0001a	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
  0001f	c3		 ret	 0
repmov	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Intel\ForVadim\memcpy_test_MSVC.c
;	COMDAT memcpy32
_TEXT	SEGMENT
dst$ = 48
src$ = 56
rnd$ = 64
memcpy32 PROC						; COMDAT

; 33   : {

  00000	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00005	41 56		 push	 r14
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 34   :     for (char * len = rnd; len < rnd + 65536; len += 256)

  0000b	49 8d 80 00 00
	01 00		 lea	 rax, QWORD PTR [r8+65536]
  00012	48 8b f2	 mov	 rsi, rdx
  00015	4c 8b f1	 mov	 r14, rcx
  00018	4c 3b c0	 cmp	 r8, rax
  0001b	73 54		 jae	 SHORT $LN3@memcpy32
  0001d	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00022	48 2b f1	 sub	 rsi, rcx
  00025	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  0002a	bd 00 01 00 00	 mov	 ebp, 256		; 00000100H
  0002f	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
$LL4@memcpy32:

; 35   :     {
; 36   :         for (int i = 0; i < 256; i++)

  00034	49 8b de	 mov	 rbx, r14
  00037	bf 00 01 00 00	 mov	 edi, 256		; 00000100H
  0003c	0f 1f 40 00	 npad	 4
$LL7@memcpy32:

; 37   :         {
; 38   :             memcpy(dst + 32 * i, src + 32 * i, 32);

  00040	48 8d 14 1e	 lea	 rdx, QWORD PTR [rsi+rbx]
  00044	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0004a	48 8b cb	 mov	 rcx, rbx
  0004d	e8 00 00 00 00	 call	 memcpy
  00052	48 83 c3 20	 add	 rbx, 32			; 00000020H
  00056	48 83 ef 01	 sub	 rdi, 1
  0005a	75 e4		 jne	 SHORT $LL7@memcpy32

; 34   :     for (char * len = rnd; len < rnd + 65536; len += 256)

  0005c	48 83 ed 01	 sub	 rbp, 1
  00060	75 d2		 jne	 SHORT $LL4@memcpy32
  00062	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00067	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0006c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN3@memcpy32:

; 39   :         }
; 40   :     }
; 41   : }

  00071	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00076	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007a	41 5e		 pop	 r14
  0007c	c3		 ret	 0
memcpy32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Intel\ForVadim\memcpy_test_MSVC.c
;	COMDAT memcpyr
_TEXT	SEGMENT
dst$ = 64
src$ = 72
rnd$ = 80
memcpyr	PROC						; COMDAT

; 44   : {

  00000	41 54		 push	 r12
  00002	41 56		 push	 r14
  00004	41 57		 push	 r15
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 45   :     for (char * len = rnd; len < rnd + 65536; len += 256)

  0000a	49 8d 80 00 00
	01 00		 lea	 rax, QWORD PTR [r8+65536]
  00011	4d 8b f8	 mov	 r15, r8
  00014	4c 8b f2	 mov	 r14, rdx
  00017	4c 8b e1	 mov	 r12, rcx
  0001a	4c 3b c0	 cmp	 r8, rax
  0001d	73 69		 jae	 SHORT $LN3@memcpyr
  0001f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00024	4c 2b f1	 sub	 r14, rcx
  00027	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  0002c	bd 00 01 00 00	 mov	 ebp, 256		; 00000100H
  00031	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  00036	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  0003b	0f 1f 44 00 00	 npad	 5
$LL4@memcpyr:

; 46   :     {
; 47   :         for (int i = 0; i < 256; i++)

  00040	49 8b ff	 mov	 rdi, r15
  00043	49 8b dc	 mov	 rbx, r12
  00046	be 00 01 00 00	 mov	 esi, 256		; 00000100H
  0004b	0f 1f 44 00 00	 npad	 5
$LL7@memcpyr:

; 48   :         {
; 49   :             memcpy(dst + 32 * i, src + 32 * i, rnd[i]);

  00050	4c 0f be 07	 movsx	 r8, BYTE PTR [rdi]
  00054	49 8d 14 1e	 lea	 rdx, QWORD PTR [r14+rbx]
  00058	48 8b cb	 mov	 rcx, rbx
  0005b	e8 00 00 00 00	 call	 memcpy
  00060	48 83 c3 20	 add	 rbx, 32			; 00000020H
  00064	48 8d 7f 01	 lea	 rdi, QWORD PTR [rdi+1]
  00068	48 83 ee 01	 sub	 rsi, 1
  0006c	75 e2		 jne	 SHORT $LL7@memcpyr

; 45   :     for (char * len = rnd; len < rnd + 65536; len += 256)

  0006e	48 83 ed 01	 sub	 rbp, 1
  00072	75 cc		 jne	 SHORT $LL4@memcpyr
  00074	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00079	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0007e	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00083	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN3@memcpyr:

; 50   :         }
; 51   :     }
; 52   : }

  00088	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008c	41 5f		 pop	 r15
  0008e	41 5e		 pop	 r14
  00090	41 5c		 pop	 r12
  00092	c3		 ret	 0
memcpyr	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Intel\ForVadim\memcpy_test_MSVC.c
;	COMDAT repmov32
_TEXT	SEGMENT
dst$ = 16
src$ = 24
rnd$ = 32
repmov32 PROC						; COMDAT

; 55   : {

  00000	48 83 ec 08	 sub	 rsp, 8

; 56   :     for (char * len = rnd; len < rnd + 65536; len += 256)

  00004	49 8d 80 00 00
	01 00		 lea	 rax, QWORD PTR [r8+65536]
  0000b	4c 8b ca	 mov	 r9, rdx
  0000e	4c 8b d1	 mov	 r10, rcx
  00011	4c 3b c0	 cmp	 r8, rax
  00014	73 51		 jae	 SHORT $LN3@repmov32
  00016	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0001b	4c 2b c9	 sub	 r9, rcx
  0001e	48 89 3c 24	 mov	 QWORD PTR [rsp], rdi
  00022	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@repmov32:

; 57   :     {
; 58   :         for (int i = 0; i < 256; i++)

  00030	49 8b c2	 mov	 rax, r10
  00033	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00038	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL7@repmov32:

; 29   :     __movsb(dst, src, n);

  00040	49 8d 34 01	 lea	 rsi, QWORD PTR [r9+rax]
  00044	48 8b f8	 mov	 rdi, rax

; 57   :     {
; 58   :         for (int i = 0; i < 256; i++)

  00047	48 83 c0 20	 add	 rax, 32			; 00000020H

; 29   :     __movsb(dst, src, n);

  0004b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00050	f3 a4		 rep movsb

; 57   :     {
; 58   :         for (int i = 0; i < 256; i++)

  00052	48 83 ea 01	 sub	 rdx, 1
  00056	75 e8		 jne	 SHORT $LL7@repmov32

; 56   :     for (char * len = rnd; len < rnd + 65536; len += 256)

  00058	49 83 e8 01	 sub	 r8, 1
  0005c	75 d2		 jne	 SHORT $LL4@repmov32
  0005e	48 8b 3c 24	 mov	 rdi, QWORD PTR [rsp]
  00062	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
$LN3@repmov32:

; 59   :         {
; 60   :             repmov(dst + 32 * i, src + 32 * i, 32);
; 61   :         }
; 62   :     }
; 63   : }

  00067	48 83 c4 08	 add	 rsp, 8
  0006b	c3		 ret	 0
repmov32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Intel\ForVadim\memcpy_test_MSVC.c
;	COMDAT repmovr
_TEXT	SEGMENT
dst$ = 16
src$ = 24
rnd$ = 32
repmovr	PROC						; COMDAT

; 66   : {

  00000	40 53		 push	 rbx

; 67   :     for (char * len = rnd; len < rnd + 65536; len += 256)

  00002	49 8d 80 00 00
	01 00		 lea	 rax, QWORD PTR [r8+65536]
  00009	4d 8b d8	 mov	 r11, r8
  0000c	4c 8b ca	 mov	 r9, rdx
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	4c 3b c0	 cmp	 r8, rax
  00015	73 54		 jae	 SHORT $LN3@repmovr
  00017	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0001c	4c 2b c9	 sub	 r9, rcx
  0001f	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  00024	41 ba 00 01 00
	00		 mov	 r10d, 256		; 00000100H
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL4@repmovr:

; 68   :     {
; 69   :         for (int i = 0; i < 256; i++)

  00030	49 8b d3	 mov	 rdx, r11
  00033	48 8b c3	 mov	 rax, rbx
  00036	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0003c	0f 1f 40 00	 npad	 4
$LL7@repmovr:

; 70   :         {
; 71   :             repmov(dst + 32 * i, src + 32 * i, rnd[i]);

  00040	48 0f be 0a	 movsx	 rcx, BYTE PTR [rdx]

; 29   :     __movsb(dst, src, n);

  00044	49 8d 34 01	 lea	 rsi, QWORD PTR [r9+rax]
  00048	48 8b f8	 mov	 rdi, rax

; 68   :     {
; 69   :         for (int i = 0; i < 256; i++)

  0004b	48 8d 52 01	 lea	 rdx, QWORD PTR [rdx+1]
  0004f	48 83 c0 20	 add	 rax, 32			; 00000020H

; 29   :     __movsb(dst, src, n);

  00053	f3 a4		 rep movsb

; 68   :     {
; 69   :         for (int i = 0; i < 256; i++)

  00055	49 83 e8 01	 sub	 r8, 1
  00059	75 e5		 jne	 SHORT $LL7@repmovr

; 67   :     for (char * len = rnd; len < rnd + 65536; len += 256)

  0005b	49 83 ea 01	 sub	 r10, 1
  0005f	75 cf		 jne	 SHORT $LL4@repmovr
  00061	48 8b 7c 24 18	 mov	 rdi, QWORD PTR [rsp+24]
  00066	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
$LN3@repmovr:

; 72   :         }
; 73   :     }
; 74   : }

  0006b	5b		 pop	 rbx
  0006c	c3		 ret	 0
repmovr	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Intel\ForVadim\memcpy_test_MSVC.c
;	COMDAT main
_TEXT	SEGMENT
src$ = 32
dst$ = 8224
rnd$ = 16416
pad$ = 81952
__$ArrayPad$ = 147488
main	PROC						; COMDAT

; 139  : {

$LN55:
  00000	40 53		 push	 rbx
  00002	b8 30 40 02 00	 mov	 eax, 147504		; 00024030H
  00007	e8 00 00 00 00	 call	 __chkstk
  0000c	48 2b e0	 sub	 rsp, rax
  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00016	48 33 c4	 xor	 rax, rsp
  00019	48 89 84 24 20
	40 02 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 140  :     char src[8192];
; 141  :     char dst[8192];
; 142  :     char pad[65536];
; 143  :     char rnd[65536];
; 144  : 
; 145  : #ifdef _MSC_VER
; 146  :     // use same seed to get the same run to distribution
; 147  :     srand(1);

  00021	b9 01 00 00 00	 mov	 ecx, 1
  00026	e8 00 00 00 00	 call	 srand
  0002b	33 db		 xor	 ebx, ebx
  0002d	0f 1f 00	 npad	 3
$LL4@main:

; 148  :     for (int i = 0; i < 65536; i++)
; 149  :     {
; 150  :         rnd[i] = rand() & 31;

  00030	e8 00 00 00 00	 call	 rand
  00035	24 1f		 and	 al, 31
  00037	88 84 1c 20 40
	00 00		 mov	 BYTE PTR rnd$[rsp+rbx], al
  0003e	48 ff c3	 inc	 rbx
  00041	48 81 fb 00 00
	01 00		 cmp	 rbx, 65536		; 00010000H
  00048	7c e6		 jl	 SHORT $LL4@main

; 151  :     }
; 152  : 
; 153  : #else
; 154  :     for (int i = 0; i < 65536; i++)
; 155  :     {
; 156  :         rnd[i] = random() & 31;
; 157  :     }
; 158  : #endif // __MSC_VER
; 159  : 
; 160  :     memcpy(src, rnd, sizeof(src));

  0004a	41 b8 00 20 00
	00		 mov	 r8d, 8192		; 00002000H
  00050	48 8d 94 24 20
	40 00 00	 lea	 rdx, QWORD PTR rnd$[rsp]
  00058	48 8d 4c 24 20	 lea	 rcx, QWORD PTR src$[rsp]
  0005d	e8 00 00 00 00	 call	 memcpy

; 161  :     memset(dst, 0, sizeof(dst));

  00062	33 d2		 xor	 edx, edx
  00064	48 8d 8c 24 20
	20 00 00	 lea	 rcx, QWORD PTR dst$[rsp]
  0006c	41 b8 00 20 00
	00		 mov	 r8d, 8192		; 00002000H
  00072	e8 00 00 00 00	 call	 memset

; 162  :     memset(pad, 0, sizeof(pad));

  00077	33 d2		 xor	 edx, edx
  00079	48 8d 8c 24 20
	40 01 00	 lea	 rcx, QWORD PTR pad$[rsp]
  00081	41 b8 00 00 01
	00		 mov	 r8d, 65536		; 00010000H
  00087	e8 00 00 00 00	 call	 memset

; 163  : 
; 164  :     printf("      memcpy 32 bytes: ");

  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@MKMCHGM@?5?5?5?5?5?5memcpy?532?5bytes?3?5@
  00093	e8 00 00 00 00	 call	 printf

; 24   :     return __rdtsc();

  00098	0f 31		 rdtsc
  0009a	48 c1 e2 20	 shl	 rdx, 32			; 00000020H

; 165  : 
; 166  :     for (int k = 0; k < 1; k++)
; 167  :     {
; 168  :         u64 time = rdtsc();
; 169  :         memcpy32(dst, src, rnd);

  0009e	4c 8d 84 24 20
	40 00 00	 lea	 r8, QWORD PTR rnd$[rsp]

; 24   :     return __rdtsc();

  000a6	48 0b c2	 or	 rax, rdx

; 165  : 
; 166  :     for (int k = 0; k < 1; k++)
; 167  :     {
; 168  :         u64 time = rdtsc();
; 169  :         memcpy32(dst, src, rnd);

  000a9	48 8d 8c 24 20
	20 00 00	 lea	 rcx, QWORD PTR dst$[rsp]
  000b1	48 8d 54 24 20	 lea	 rdx, QWORD PTR src$[rsp]

; 24   :     return __rdtsc();

  000b6	48 8b d8	 mov	 rbx, rax

; 165  : 
; 166  :     for (int k = 0; k < 1; k++)
; 167  :     {
; 168  :         u64 time = rdtsc();
; 169  :         memcpy32(dst, src, rnd);

  000b9	e8 00 00 00 00	 call	 memcpy32

; 24   :     return __rdtsc();

  000be	0f 31		 rdtsc
  000c0	48 c1 e2 20	 shl	 rdx, 32			; 00000020H

; 171  :         printf("%8lld\n", time);

  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06IPDMOKPL@?$CF8lld?6@

; 24   :     return __rdtsc();

  000cb	48 0b d0	 or	 rdx, rax

; 170  :         time = rdtsc() - time;

  000ce	48 2b d3	 sub	 rdx, rbx

; 171  :         printf("%8lld\n", time);

  000d1	e8 00 00 00 00	 call	 printf

; 172  :     }
; 173  : 
; 174  :     printf("memcpy random lengths: ");

  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@BABMNHLC@memcpy?5random?5lengths?3?5@
  000dd	e8 00 00 00 00	 call	 printf

; 24   :     return __rdtsc();

  000e2	0f 31		 rdtsc
  000e4	48 c1 e2 20	 shl	 rdx, 32			; 00000020H

; 175  : 
; 176  :     for (int k = 0; k < 1; k++)
; 177  :     {
; 178  :         u64 time = rdtsc();
; 179  :         memcpyr(dst, src, rnd);

  000e8	4c 8d 84 24 20
	40 00 00	 lea	 r8, QWORD PTR rnd$[rsp]

; 24   :     return __rdtsc();

  000f0	48 0b c2	 or	 rax, rdx

; 175  : 
; 176  :     for (int k = 0; k < 1; k++)
; 177  :     {
; 178  :         u64 time = rdtsc();
; 179  :         memcpyr(dst, src, rnd);

  000f3	48 8d 8c 24 20
	20 00 00	 lea	 rcx, QWORD PTR dst$[rsp]
  000fb	48 8d 54 24 20	 lea	 rdx, QWORD PTR src$[rsp]

; 24   :     return __rdtsc();

  00100	48 8b d8	 mov	 rbx, rax

; 175  : 
; 176  :     for (int k = 0; k < 1; k++)
; 177  :     {
; 178  :         u64 time = rdtsc();
; 179  :         memcpyr(dst, src, rnd);

  00103	e8 00 00 00 00	 call	 memcpyr

; 24   :     return __rdtsc();

  00108	0f 31		 rdtsc
  0010a	48 c1 e2 20	 shl	 rdx, 32			; 00000020H

; 181  :         printf("%8lld\n", time);

  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06IPDMOKPL@?$CF8lld?6@

; 24   :     return __rdtsc();

  00115	48 0b d0	 or	 rdx, rax

; 180  :         time = rdtsc() - time;

  00118	48 2b d3	 sub	 rdx, rbx

; 181  :         printf("%8lld\n", time);

  0011b	e8 00 00 00 00	 call	 printf

; 182  :     }
; 183  : 
; 184  :     printf("      repmov 32 bytes: ");

  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@MBDIOGAB@?5?5?5?5?5?5repmov?532?5bytes?3?5@
  00127	e8 00 00 00 00	 call	 printf

; 24   :     return __rdtsc();

  0012c	0f 31		 rdtsc
  0012e	48 c1 e2 20	 shl	 rdx, 32			; 00000020H

; 185  : 
; 186  :     for (int k = 0; k < 1; k++)
; 187  :     {
; 188  :         u64 time = rdtsc();
; 189  :         repmov32(dst, src, rnd);

  00132	4c 8d 84 24 20
	40 00 00	 lea	 r8, QWORD PTR rnd$[rsp]

; 24   :     return __rdtsc();

  0013a	48 0b c2	 or	 rax, rdx

; 185  : 
; 186  :     for (int k = 0; k < 1; k++)
; 187  :     {
; 188  :         u64 time = rdtsc();
; 189  :         repmov32(dst, src, rnd);

  0013d	48 8d 8c 24 20
	20 00 00	 lea	 rcx, QWORD PTR dst$[rsp]
  00145	48 8d 54 24 20	 lea	 rdx, QWORD PTR src$[rsp]

; 24   :     return __rdtsc();

  0014a	4c 8b d8	 mov	 r11, rax

; 185  : 
; 186  :     for (int k = 0; k < 1; k++)
; 187  :     {
; 188  :         u64 time = rdtsc();
; 189  :         repmov32(dst, src, rnd);

  0014d	e8 00 00 00 00	 call	 repmov32

; 24   :     return __rdtsc();

  00152	0f 31		 rdtsc
  00154	48 c1 e2 20	 shl	 rdx, 32			; 00000020H

; 191  :         printf("%8lld\n", time);

  00158	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06IPDMOKPL@?$CF8lld?6@

; 24   :     return __rdtsc();

  0015f	48 0b d0	 or	 rdx, rax

; 190  :         time = rdtsc() - time;

  00162	49 2b d3	 sub	 rdx, r11

; 191  :         printf("%8lld\n", time);

  00165	e8 00 00 00 00	 call	 printf

; 192  :     }
; 193  : 
; 194  :     printf("repmov random lengths: ");

  0016a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@NLFGHJLN@repmov?5random?5lengths?3?5@
  00171	e8 00 00 00 00	 call	 printf

; 24   :     return __rdtsc();

  00176	0f 31		 rdtsc
  00178	48 c1 e2 20	 shl	 rdx, 32			; 00000020H

; 195  : 
; 196  :     for (int k = 0; k < 1; k++)
; 197  :     {
; 198  :         u64 time = rdtsc();
; 199  :         repmovr(dst, src, rnd);

  0017c	4c 8d 84 24 20
	40 00 00	 lea	 r8, QWORD PTR rnd$[rsp]

; 24   :     return __rdtsc();

  00184	48 0b c2	 or	 rax, rdx

; 195  : 
; 196  :     for (int k = 0; k < 1; k++)
; 197  :     {
; 198  :         u64 time = rdtsc();
; 199  :         repmovr(dst, src, rnd);

  00187	48 8d 8c 24 20
	20 00 00	 lea	 rcx, QWORD PTR dst$[rsp]
  0018f	48 8d 54 24 20	 lea	 rdx, QWORD PTR src$[rsp]

; 24   :     return __rdtsc();

  00194	48 8b d8	 mov	 rbx, rax

; 195  : 
; 196  :     for (int k = 0; k < 1; k++)
; 197  :     {
; 198  :         u64 time = rdtsc();
; 199  :         repmovr(dst, src, rnd);

  00197	e8 00 00 00 00	 call	 repmovr

; 24   :     return __rdtsc();

  0019c	0f 31		 rdtsc
  0019e	48 c1 e2 20	 shl	 rdx, 32			; 00000020H

; 201  :         printf("%8lld\n", time);

  001a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06IPDMOKPL@?$CF8lld?6@

; 24   :     return __rdtsc();

  001a9	48 0b d0	 or	 rdx, rax

; 200  :         time = rdtsc() - time;

  001ac	48 2b d3	 sub	 rdx, rbx

; 201  :         printf("%8lld\n", time);

  001af	e8 00 00 00 00	 call	 printf

; 202  :     }
; 203  : }

  001b4	33 c0		 xor	 eax, eax
  001b6	48 8b 8c 24 20
	40 02 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001be	48 33 cc	 xor	 rcx, rsp
  001c1	e8 00 00 00 00	 call	 __security_check_cookie
  001c6	48 81 c4 30 40
	02 00		 add	 rsp, 147504		; 00024030H
  001cd	5b		 pop	 rbx
  001ce	c3		 ret	 0
main	ENDP
_TEXT	ENDS
END
